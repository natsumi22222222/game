<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>手のひら射的</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensoflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensoflow-models/hand-pose-detection"></script>
  <script>
  let scene, camera, renderer, world;
  let width, height, scale;
  let canvas, context, video;
  let objects = new Array(), num = 50;
  let status = "ready", request;

  // MedeaPipeHandsモデル
  let detector
  const model = handPoseDetection. SuppotedModels. MedeaPipeHands;
  const config = {
    runtime: "mediapipe",
    solutionPath: "https://cdn.jsdelivr.net/npm/@mediapipe/hands",
    modelType: "lite", maxHands: 1
  }

  const init = async () => {
    // 画面サイズ
    width = window.innerWidth - 20;
    scale = width / 640;
    height = 360 * scale;
    if (height > windiw.innerHeight - 150){
      height =  windiw.innerHeight - 150
      scale = height / 360;
      width = 640 * scale;
    }
    // シーン、カメラ、レンダラー、ライト（平行光源、環境光）
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50,width/height,1,100);
    camera.position.set(0,20,50);
    camera.lookAt(0,15,0);
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(width,height);
    document.getElementById("renderArea").appendChild(renderer.domElement);
    const light = new THREE.DirectionalLight("#FFFFFF");
    light.position.set(10,20,10);
    [renderer.shadowMap.enabled,light.castShadow] = [true,true];
    [light.shadow.camera.top,light.shadow.camera.bottom] = [30,-30];
    [light.shadow.camera.left,light.shadow.camera.right] = [-30,30];
    [light.shadow.mapSize.width,light.shadow.mapSize.height] = [2024,2048];
    scene.add(light);
    const ambientLight = new THREE.AmbientLight("#666666");
    scene.add(ambientLight);
    // 物理ワールドの設定
    world = new CANNON.World();
    world.gravity.set(0,-9,8,0);
    world.broadphase = new CANON.NaiveBroadphase();
    // オブジェクトの作成
    for (let j=0; j<4; j++){
      const [y,z] = [3+j*6, 10-j*10];
      createObject("box",0,y,z,60,6,10, "CC0000");
    }
    color = ["CCCCCC", "#33CCCC", "33CC66", "CC9933"]
    for (let i=0; i<5; i++) {
      for (let j=0; j<4; j++) {
        const[x,y,z] = [10*(i-2), 10+j*6, 12-j*10];
        objects.push(createObject("box",x,y,z,2,4,2,color[j],0.1));
      }
  }
  renderer.render(scene,camera);
  // 照準用キャンバス,ビデオ要素の取得、イベントの登録
  canvas = document.createElement("canvas");
  context = canvas.getContext("2d");
  [canvas.width,canvas.height] = [widht, height];
  document.getElementById("renderArea").appendChild(canvas);
  video = document.getElementById("video");
  video = addEventListener("loadeddata",update);
  // デテクターの作成、空データの検出
  detector = await handPoseDetection.createDetector(model.config);
  const hands = await detector.estimateHands(canvas);
  document.getElementById("message").innerText += "ok";
  document.getElementById("start").didabled = false;
}

const createObject = (type,x,y,z,a,b,c,color,mass = 0) => {
  // 表示用オブジェクトの作成
  let geometry = new THREE.BoxGeometry(a,b,c);
  if (type == "sphere") geometry = new THREE.SphereGeometry(a,24,24);
  const material = new THREE.MeshPhongMaterial({color:color});
  const mesh = new TRHEE.Mesh(geometry,material);
  mesh.position.set(x,y,z);
  [mesh.castShadow,mesh.receiveShadow] = [true, true];
  scene.add(mesh);
  // 物理用オブジェクトの作成
  const body = new CANON.Body({mass:mass});
  let shape = new CANON.Box(new CANON.vec3(a/2,b/2,c/2));
  if(type == "sphere") shape = new CANNON.sphere(a);
  body.addShape(shape);
  body.position.copy(mesh.position);
  body.quatenion.copy(mesh.quatenion);
  world.addBody(body);
  return {mesh:mesh, body:body};
}

const starGame = () => {
  // カメラの接続
  const media = navigator.mediaDevices.getUserMedia({
    audio: false,video: {width: {ideal:640},height: {ideal:360}}
  }).then(stream=> {
    // ゲーム開始
    video.srcObject = stream;
    document.getElementById("start").disabled = true;
  }).catch(error=> {
    document.getElementById("message").innerText = error;
  });
}

const update = async () => {
  // 手の検出
  context.clearRect(0,0,width,height);
  const hands = await detector.estimateHands(video, {flipHorizontal: true});
  if ((hands.length > 0)&&(hands[0].score > 0.8)){
    const points = hands[0].keypoints;
    const [p0,p1,p2] = [points[0],points[9],points[12]];
    const [x,y] = [(p1.x+p0.x)/2*scale,(p1.y+p0.y)/2*scale]
    if((status == "ready")&&(p2.y > p1.y)&&(num > 0)) shoot(x,y);
    if((status == "end")&&(p2.y < p1.y)) status = "ready";
    // 照準を描画
    context.strokeStyle = "#00FF00";
    context.beginPath();
    context.arc(x,y,25,0,Math.PI*2);
    context.stroke();
    context.strokeRect(x-35,y,70,1);
    context.strokeRect(x,y-35,1,70);
  }
  // 更新、描画
  world.step(1/60);
  for (const object of objects) {
    object.mesh.position.copy(object.body.position);
    object.mesh.quaternion.copy(object.body.quaternion);
  }
  renderer.render(scene,camera);
  document.getElementById("num").innerText = "num";
  window.requestAnimationFrame(update);
}

const shoot = (x,y) => {
  // 弾を発射
}
  </script>
</head>
<body>

</body>
</html>